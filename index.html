<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>DP Moto</title>
  <style>
    @font-face {
      font-family: 'Alagard';
      src: url('/assets/fonts/alagard.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: block;
    }
    @font-face {
      font-family: 'Early GameBoy';
      src: url('/assets/fonts/Early GameBoy.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: block;
    }
    @font-face {
      font-family: 'Retro Gaming';
      src: url('/assets/fonts/Retro Gaming.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: block;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      cursor: none;
    }
    #game-container {
      width: 100%;
      height: 100%;
      position: relative;
    }

    /* ===== BIOS BOOT OVERLAY ===== */
    /* ---- CRT TUNING (edit these) ---- */
    :root {
      --bios-color:             #ff2a2a;   /* main text & bar color            */
      --bios-glow:              #aa0000;   /* outer glow / shadow color        */
      --bios-glow-bright:       #ff6666;   /* inner highlight on bar           */
      --bios-glow-radius:       8px;       /* text-shadow glow spread          */
      --bios-scanline-opacity:  0.5;      /* scanline darkness (0 = off)      */
      --bios-scanline-gap:      3px;       /* px between scanlines             */
      --bios-vignette-start:    50%;       /* vignette transparent center      */
      --bios-vignette-opacity:  0.6;       /* vignette edge darkness           */
      --bios-flicker-speed:     0.08s;     /* flicker animation cycle          */
      --bios-flicker-min:       0.97;      /* min opacity during flicker       */
      --bios-jitter-speed:      0.1s;      /* vertical jitter cycle            */
      --bios-jitter-amount:     1px;     /* px of vertical jitter            */
      --bios-font-size:         clamp(12px, 2vw, 18px);
      --bios-line-height:       1.8;
      --bios-title-font:        'Alagard', 'Courier New', monospace;
      --bios-title-size:        clamp(16px, 3vw, 42px);
      --bios-scale:             2;             /* scale multiplier for entire BIOS group     */
      --bios-row-gap:           20px;           /* extra spacing between text rows             */
      --bios-text-top:          -169px;           /* Y offset of first text row within group     */
      --bios-bar-top:           180px;         /* Y offset of loading bar within group        */
    }

    #boot-overlay {
      position: fixed;
      inset: 0;
      z-index: 99999;
      background: #000;
      font-family: 'Early GameBoy', 'Courier New', monospace;
      color: var(--bios-color);
      animation: bios-flicker var(--bios-flicker-speed) infinite alternate;
    }
    #boot-overlay.hidden { display: none; }
    #boot-overlay ::selection { background: var(--bios-color); color: #000; }

    /* CRT scanlines overlay */
    #boot-overlay::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,var(--bios-scanline-opacity)) 0px,
        rgba(0,0,0,var(--bios-scanline-opacity)) 1px,
        transparent 1px,
        transparent var(--bios-scanline-gap)
      );
      pointer-events: none;
      z-index: 2;
    }
    /* CRT vignette overlay */
    #boot-overlay::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center,
        transparent var(--bios-vignette-start),
        rgba(0,0,0,var(--bios-vignette-opacity)) 100%);
      pointer-events: none;
      z-index: 2;
    }

    @keyframes bios-flicker {
      0%   { opacity: 1; }
      100% { opacity: var(--bios-flicker-min); }
    }
    @keyframes bios-jitter {
      0%   { transform: translateY(0); }
      100% { transform: translateY(var(--bios-jitter-amount)); }
    }

    #boot-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(var(--bios-scale));
      width: clamp(240px, 40vw, 420px);
      z-index: 1;
    }
    #boot-lines {
      position: absolute;
      top: var(--bios-text-top);
      left: 0;
      right: 0;
      text-align: left;
      font-size: var(--bios-font-size);
      line-height: var(--bios-line-height);
      text-shadow: 0 0 var(--bios-glow-radius) var(--bios-glow),
                   0 0 2px var(--bios-color);
      animation: bios-jitter var(--bios-jitter-speed) infinite alternate;
      display: flex;
      flex-direction: column;
      gap: var(--bios-row-gap);
    }
    #boot-lines .line {
      white-space: pre;
      visibility: hidden;
    }
    #boot-lines .line.visible {
      visibility: visible;
    }
    #boot-lines .line:first-child {
      font-family: var(--bios-title-font);
      font-size: var(--bios-title-size);
    }

    #boot-bar-wrap {
      position: absolute;
      top: var(--bios-bar-top);
      left: 0;
      right: 0;
      height: 14px;
      animation: bios-jitter var(--bios-jitter-speed) infinite alternate;
      border: 1px solid var(--bios-color);
      background: #111;
      box-shadow: 0 0 6px var(--bios-glow);
      overflow: hidden;
    }
    #boot-bar-fill {
      height: 100%;
      width: 10%;
      background: var(--bios-color);
      box-shadow: inset 0 0 4px var(--bios-glow-bright);
      transition: width 0.15s linear;
    }

    /* "[ enter ]" prompt — shown before BIOS starts */
    #boot-enter-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: var(--bios-title-font);
      font-size: clamp(24px, 5vw, 56px);
      color: var(--bios-color);
      text-shadow: 0 0 var(--bios-glow-radius) var(--bios-glow),
                   0 0 2px var(--bios-color);
      z-index: 1;
      animation: enter-blink 1350ms infinite;
    }
    @keyframes enter-blink {
      0%   { opacity: 1; }
      53%  { opacity: 1; }       /* visible 800ms / 1350ms ≈ 59% */
      63%  { opacity: 0; }       /* fade out ~150ms */
      83%  { opacity: 0; }       /* hidden 400ms */
      93%  { opacity: 1; }       /* fade in ~150ms */
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- BIOS boot overlay — renders instantly before any JS -->
  <div id="boot-overlay">
    <div id="boot-enter-prompt">[ enter ]</div>
    <div id="boot-content" style="display:none;">
      <div id="boot-lines">
        <div class="line" data-text="DP MOTO BIOS      v0.1"></div>
        <div class="line" data-text="VIDEO  ............... OK"></div>
        <div class="line" data-text="AUDIO  ............. SURE"></div>
        <div class="line" data-text="LOADING GAME ........ WTV"></div>
      </div>
      <div id="boot-bar-wrap">
        <div id="boot-bar-fill"></div>
      </div>
    </div>
  </div>

  <script>
  // ---- CURSOR TUNING (shared between BIOS overlay & in-game) ----
  window.__cursorConfig = {
    size: 40,              // display height in px
    strokeW: 6.9,            // stroke thickness in px (0 = no stroke)
    tint: 0xff0000,        // fill color (red)
    strokeColor: 0x000000, // stroke color (white)
  };

  // Prevent unhandled errors from crashing iOS Safari (which reloads the page)
  window.addEventListener('error', function(e) {
    console.error('Uncaught error:', e.error || e.message);
    e.preventDefault();
  });
  window.addEventListener('unhandledrejection', function(e) {
    console.error('Unhandled rejection:', e.reason);
    e.preventDefault();
  });

  // Boot overlay API — available immediately, before any module JS loads
  (function() {
    /* ---- TYPEWRITER TUNING (edit these) ---- */
    var DOT_TIME_PERCENT = 0.85;  // fraction of loading progress that dots consume
    var DOT_POP_MS       = 60;    // min ms between each dot popping on
    var WORD_POP_MS      = 30;    // ms pause after a word chunk appears

    var fill = document.getElementById('boot-bar-fill');
    var lineEls = document.querySelectorAll('#boot-lines .line');
    var overlay = document.getElementById('boot-overlay');
    var bootLinesEl = document.getElementById('boot-lines');
    var enterPrompt = document.getElementById('boot-enter-prompt');
    var bootContent = document.getElementById('boot-content');
    var biosStarted = false;
    var pendingProgress = [];  // buffer setProgress calls until BIOS starts

    // Click sound during BIOS overlay (only after BIOS starts)
    var biosClickAudio = new Audio('assets/audio/sfx/mouse click.mp3');
    biosClickAudio.volume = 1.0;
    overlay.addEventListener('pointerdown', function() {
      if (!biosStarted) return;
      biosClickAudio.currentTime = 0;
      biosClickAudio.play().catch(function() {});
    });

    // Boot-up sound — only played when BIOS sequence begins
    var bootupAudio = new Audio('assets/audio/sfx/old_bootup.mp3');
    bootupAudio.volume = 1.0;
    bootupAudio.loop = false;

    // Wait for first keypress or click to start BIOS
    function startBios() {
      if (biosStarted) return;
      biosStarted = true;
      enterPrompt.style.display = 'none';
      bootContent.style.display = '';
      bootupAudio.play().catch(function() {});
      // Flush any buffered progress updates
      for (var p = 0; p < pendingProgress.length; p++) {
        targetProgress = pendingProgress[p];
      }
      pendingProgress = [];
      // If loading already finished while waiting for user, unlock everything
      if (loadingDone) {
        targetProgress = 2;
      }
      if (!dripScheduled) scheduleDrip(0);
      document.removeEventListener('pointerdown', startBios);
      document.removeEventListener('keydown', startBios);
    }
    document.addEventListener('pointerdown', startBios);
    document.addEventListener('keydown', startBios);

    // Build flat character list, count dots/non-dots, assign progress thresholds
    var chars = [];
    var totalDots = 0;
    var totalNonDots = 0;
    for (var i = 0; i < lineEls.length; i++) {
      var text = lineEls[i].getAttribute('data-text') || '';
      lineEls[i].textContent = '';
      for (var j = 0; j < text.length; j++) {
        var isDot = text[j] === '.';
        chars.push({ el: lineEls[i], idx: j, fullText: text, isDot: isDot, threshold: 0 });
        if (isDot) totalDots++; else totalNonDots++;
      }
    }

    // Each dot eats DOT_TIME_PERCENT/totalDots of the progress range;
    // each non-dot eats (1-DOT_TIME_PERCENT)/totalNonDots — words fly through.
    var dotW    = totalDots    > 0 ? DOT_TIME_PERCENT / totalDots : 0;
    var nonDotW = totalNonDots > 0 ? (1 - DOT_TIME_PERCENT) / totalNonDots : 0;
    var cum = 0;
    for (var k = 0; k < chars.length; k++) {
      cum += chars[k].isDot ? dotW : nonDotW;
      chars[k].threshold = cum;
    }

    var revealed = 0;
    var targetProgress = 0;
    var typingDone = false;
    var loadingDone = false;
    var dismissed = false;
    var dripScheduled = false;

    // Drip: reveal one item per tick, only if loading progress allows it
    function drip() {
      dripScheduled = false;
      if (revealed >= chars.length) { typingDone = true; syncBar(); tryDismiss(); return; }
      if (chars[revealed].threshold > targetProgress) return; // wait for more progress

      var c = chars[revealed];
      if (c.isDot) {
        if (!c.el.classList.contains('visible')) c.el.classList.add('visible');
        c.el.textContent = c.fullText.substring(0, c.idx + 1);
        revealed++;
        syncBar();
        scheduleDrip(DOT_POP_MS);
      } else {
        // Batch all consecutive non-dots whose thresholds are earned
        while (revealed < chars.length && !chars[revealed].isDot && chars[revealed].threshold <= targetProgress) {
          var ch = chars[revealed];
          if (!ch.el.classList.contains('visible')) ch.el.classList.add('visible');
          ch.el.textContent = ch.fullText.substring(0, ch.idx + 1);
          revealed++;
        }
        syncBar();
        scheduleDrip(WORD_POP_MS);
      }
    }

    // Bar tracks typewriter progress, not raw load progress
    function syncBar() {
      var pct = chars.length > 0 ? (revealed / chars.length) * 100 : 0;
      fill.style.width = pct + '%';
    }

    function scheduleDrip(delay) {
      if (dripScheduled) return;
      if (revealed >= chars.length) { typingDone = true; tryDismiss(); return; }
      if (chars[revealed].threshold <= targetProgress) {
        dripScheduled = true;
        setTimeout(drip, delay);
      }
    }

    function revealAll() {
      for (var m = 0; m < lineEls.length; m++) {
        lineEls[m].classList.add('visible');
        lineEls[m].textContent = lineEls[m].getAttribute('data-text') || '';
      }
      revealed = chars.length;
      typingDone = true;
    }

    function fadeOutBootAudio() {
      var start = bootupAudio.volume;
      var dur = 500; // ms
      var step = 16;
      var decrement = start / (dur / step);
      var fade = setInterval(function() {
        var v = bootupAudio.volume - decrement;
        if (v <= 0) {
          clearInterval(fade);
          bootupAudio.volume = 0;
          bootupAudio.pause();
        } else {
          bootupAudio.volume = v;
        }
      }, step);
    }

    // BIOS complete chime — plays when loading finishes
    var biosCompleteAudio = new Audio('assets/audio/sfx/bios complete loading.mp3');
    biosCompleteAudio.volume = 1.0;

    function tryDismiss() {
      if (dismissed || !typingDone || !loadingDone) return;
      dismissed = true;
      fadeOutBootAudio();
      biosCompleteAudio.play().catch(function() {});
      // Bar is already at 100% (set in markStartScreenReady) — just fade out
      setTimeout(function() {
        overlay.style.transition = 'opacity 0.3s ease-out';
        overlay.style.opacity = '0';
        setTimeout(function() {
          overlay.classList.add('hidden');
          if (bootCursor && bootCursor.parentNode) bootCursor.parentNode.removeChild(bootCursor);
        }, 320);
      }, 350);
    }

    window.__bootOverlay = {
      setProgress: function(p) {
        if (dismissed) return;
        if (!biosStarted) { pendingProgress.push(p); return; }
        targetProgress = p;
        if (!dripScheduled) scheduleDrip(0);
      },
      markStartScreenReady: function() {
        if (loadingDone) return;
        loadingDone = true;
        if (!biosStarted) return; // BIOS will catch up when user clicks
        // Unlock all remaining chars (use 2 to avoid floating-point edge cases)
        // Bar will reach 100% naturally as typewriter finishes via syncBar()
        targetProgress = 2;
        if (!typingDone && !dripScheduled) scheduleDrip(0);
        tryDismiss();
      }
    };

    // --- Custom cursor (reads from window.__cursorConfig) ---
    var cc = window.__cursorConfig;
    var bootCursor = document.createElement('div');
    bootCursor.style.cssText = 'position:fixed;pointer-events:none;z-index:1;display:none;' +
      'animation:bios-jitter var(--bios-jitter-speed) infinite alternate;';
    var cursorImg = new Image();
    cursorImg.onload = function() {
      var aspect = cursorImg.naturalWidth / cursorImg.naturalHeight;
      var h = cc.size;
      var sw = cc.strokeW;
      var mainH = h, mainW = Math.round(h * aspect);
      var tintHex = '#' + cc.tint.toString(16).padStart(6, '0');
      var strokeHex = '#' + cc.strokeColor.toString(16).padStart(6, '0');
      var mask = '-webkit-mask-image:url(ui/cursor.png);mask-image:url(ui/cursor.png);' +
        '-webkit-mask-size:contain;mask-size:contain;' +
        '-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;' +
        '-webkit-mask-position:center;mask-position:center;' +
        'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);';
      if (sw > 0) {
        var sH = h + sw * 2, sW = Math.round(sH * aspect);
        var strokeDiv = document.createElement('div');
        strokeDiv.style.cssText = mask + 'width:' + sW + 'px;height:' + sH + 'px;background:' + strokeHex + ';';
        bootCursor.appendChild(strokeDiv);
      }
      var mainDiv = document.createElement('div');
      mainDiv.style.cssText = mask + 'width:' + mainW + 'px;height:' + mainH + 'px;background:' + tintHex + ';';
      bootCursor.appendChild(mainDiv);
      overlay.appendChild(bootCursor);
    };
    cursorImg.src = 'ui/cursor.png';
    document.addEventListener('mousemove', function(e) {
      if (dismissed) return;
      bootCursor.style.display = '';
      bootCursor.style.left = e.clientX + 'px';
      bootCursor.style.top = e.clientY + 'px';
    });
  })();
  </script>

  <div id="game-container"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>
