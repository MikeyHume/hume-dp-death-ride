<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>DP Moto</title>
  <style>
    @font-face {
      font-family: 'Alagard';
      src: url('/assets/fonts/alagard.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: block;
    }
    @font-face {
      font-family: 'Early GameBoy';
      src: url('/assets/fonts/Early GameBoy.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: block;
    }
    @font-face {
      font-family: 'Retro Gaming';
      src: url('/assets/fonts/Retro Gaming.ttf') format('truetype');
      font-weight: normal;
      font-style: normal;
      font-display: block;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      cursor: none;
    }
    #game-container {
      width: 100%;
      height: 100%;
      position: relative;
      touch-action: none;
    }
    #game-container canvas {
      touch-action: none;
    }

    /* ===== BIOS BOOT OVERLAY ===== */
    /* ---- CRT TUNING (edit these) ---- */
    :root {
      --bios-color:             #ff2a2a;   /* main text & bar color            */
      --bios-glow:              #aa0000;   /* outer glow / shadow color        */
      --bios-glow-bright:       #ff6666;   /* inner highlight on bar           */
      --bios-glow-radius:       8px;       /* text-shadow glow spread          */
      --bios-scanline-opacity:  0.5;      /* scanline darkness (0 = off)      */
      --bios-scanline-gap:      3px;       /* px between scanlines             */
      --bios-vignette-start:    50%;       /* vignette transparent center      */
      --bios-vignette-opacity:  0.6;       /* vignette edge darkness           */
      --bios-flicker-speed:     0.08s;     /* flicker animation cycle          */
      --bios-flicker-min:       0.97;      /* min opacity during flicker       */
      --bios-jitter-speed:      0.1s;      /* vertical jitter cycle            */
      --bios-jitter-amount:     1px;     /* px of vertical jitter            */
      --bios-font-size:         clamp(12px, 2vw, 18px);
      --bios-line-height:       1.8;
      --bios-title-font:        'Alagard', 'Courier New', monospace;
      --bios-title-size:        clamp(16px, 3vw, 42px);
      --bios-scale:             2;             /* scale multiplier for entire BIOS group     */
      --bios-row-gap:           20px;           /* extra spacing between text rows             */
      --bios-text-top:          -169px;           /* Y offset of first text row within group     */
      --bios-bar-top:           180px;         /* Y offset of loading bar within group        */
      --bios-enter-top:            120px;        /* [ENTER] prompt distance below boot-content top */
      --bios-enter-scale:          .5;           /* [ENTER] prompt scale multiplier             */
    }

    #boot-overlay {
      position: fixed;
      inset: 0;
      z-index: 99999;
      background: #000;
      font-family: 'Early GameBoy', 'Courier New', monospace;
      color: var(--bios-color);
      animation: bios-flicker var(--bios-flicker-speed) infinite alternate;
    }
    #boot-overlay.hidden { display: none; }
    #boot-overlay ::selection { background: var(--bios-color); color: #000; }

    /* CRT scanlines overlay */
    #boot-overlay::before {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(
        0deg,
        rgba(0,0,0,var(--bios-scanline-opacity)) 0px,
        rgba(0,0,0,var(--bios-scanline-opacity)) 1px,
        transparent 1px,
        transparent var(--bios-scanline-gap)
      );
      pointer-events: none;
      z-index: 2;
    }
    /* CRT vignette overlay */
    #boot-overlay::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(ellipse at center,
        transparent var(--bios-vignette-start),
        rgba(0,0,0,var(--bios-vignette-opacity)) 100%);
      pointer-events: none;
      z-index: 2;
    }

    @keyframes bios-flicker {
      0%   { opacity: 1; }
      100% { opacity: var(--bios-flicker-min); }
    }
    @keyframes bios-jitter {
      0%   { transform: translateY(0); }
      100% { transform: translateY(var(--bios-jitter-amount)); }
    }

    #boot-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(var(--bios-scale));
      width: clamp(240px, 40vw, 420px);
      z-index: 1;
    }
    #boot-lines {
      position: absolute;
      top: var(--bios-text-top);
      left: 0;
      right: 0;
      text-align: left;
      font-size: var(--bios-font-size);
      line-height: var(--bios-line-height);
      text-shadow: 0 0 var(--bios-glow-radius) var(--bios-glow),
                   0 0 2px var(--bios-color);
      animation: bios-jitter var(--bios-jitter-speed) infinite alternate;
      display: flex;
      flex-direction: column;
      gap: var(--bios-row-gap);
    }
    #boot-lines .line {
      white-space: pre;
      visibility: hidden;
    }
    #boot-lines .line.visible {
      visibility: visible;
    }
    #boot-lines .line:first-child {
      font-family: var(--bios-title-font);
      font-size: var(--bios-title-size);
    }

    #boot-bar-wrap {
      position: absolute;
      top: var(--bios-bar-top);
      left: 0;
      right: 0;
      height: 14px;
      animation: bios-jitter var(--bios-jitter-speed) infinite alternate;
      border: 1px solid var(--bios-color);
      background: #111;
      box-shadow: 0 0 6px var(--bios-glow);
      overflow: hidden;
    }
    #boot-bar-fill {
      height: 100%;
      width: 10%;
      background: var(--bios-color);
      box-shadow: inset 0 0 4px var(--bios-glow-bright);
      transition: width 0.15s linear;
    }

    /* "[ ENTER ]" prompt — shown after loading finishes, right-aligned with bar */
    #boot-enter-prompt {
      display: none;
      position: absolute;
      top: var(--bios-enter-top);
      right: 0;
      text-align: right;
      font-family: var(--bios-title-font);
      font-size: clamp(24px, 5vw, 56px);
      transform: scale(var(--bios-enter-scale));
      transform-origin: right center;
      color: var(--bios-color);
      text-shadow: 0 0 var(--bios-glow-radius) var(--bios-glow),
                   0 0 2px var(--bios-color);
      z-index: 1;
      animation: enter-blink 1350ms infinite, enter-jitter var(--bios-jitter-speed) infinite alternate;
    }
    @keyframes enter-jitter {
      0%   { transform: scale(var(--bios-enter-scale)) translateY(0); }
      100% { transform: scale(var(--bios-enter-scale)) translateY(var(--bios-jitter-amount)); }
    }
    @keyframes enter-blink {
      0%   { opacity: 1; }
      53%  { opacity: 1; }
      63%  { opacity: 0; }
      83%  { opacity: 0; }
      93%  { opacity: 1; }
      100% { opacity: 1; }
    }
  </style>
</head>
<body>
  <!-- BIOS boot overlay — renders instantly before any JS -->
  <div id="boot-overlay">
    <div id="boot-content">
      <div id="boot-lines">
        <div class="line" data-text="DP MOTO BIOS      v0.1"></div>
        <div class="line" data-text="VIDEO  ............... OK"></div>
        <div class="line" data-text="AUDIO  ............. SURE"></div>
        <div class="line" data-text="LOADING GAME ........ WTV"></div>
      </div>
      <div id="boot-bar-wrap">
        <div id="boot-bar-fill"></div>
      </div>
      <div id="boot-enter-prompt">[ ENTER ]</div>
    </div>
  </div>

  <script>
  // ---- CURSOR TUNING (shared between BIOS overlay & in-game) ----
  window.__cursorConfig = {
    size: 40,              // display height in px
    strokeW: 6.9,            // stroke thickness in px (0 = no stroke)
    tint: 0xff0000,        // fill color (red)
    strokeColor: 0x000000, // stroke color (white)
    offsetX: 12,           // px offset to align tip with real cursor (+ = right)
    offsetY: 20,           // px offset to align tip with real cursor (+ = down)
  };

  // Prevent unhandled errors from crashing iOS Safari (which reloads the page)
  window.addEventListener('error', function(e) {
    console.error('Uncaught error:', e.error || e.message);
    e.preventDefault();
  });
  window.addEventListener('unhandledrejection', function(e) {
    console.error('Unhandled rejection:', e.reason);
    e.preventDefault();
  });

  // Boot overlay API — available immediately, before any module JS loads
  (function() {
    /* ---- TYPEWRITER TUNING (edit these) ---- */
    var DOT_TIME_PERCENT = 0.85;  // fraction of loading progress that dots consume
    var DOT_POP_MS       = 60;    // min ms between each dot popping on
    var WORD_POP_MS      = 30;    // ms pause after a word chunk appears

    var fill = document.getElementById('boot-bar-fill');
    var lineEls = document.querySelectorAll('#boot-lines .line');
    var overlay = document.getElementById('boot-overlay');
    var bootLinesEl = document.getElementById('boot-lines');
    var enterPrompt = document.getElementById('boot-enter-prompt');
    var bootContent = document.getElementById('boot-content');
    var biosStarted = true;  // start BIOS immediately (no terminal phase)
    var readyForEnter = false;  // true once loading bar finishes

    // Click sound during BIOS overlay
    var biosClickAudio = new Audio('assets/audio/sfx/mouse click.mp3');
    biosClickAudio.volume = 1.0;
    overlay.addEventListener('pointerdown', function() {
      biosClickAudio.currentTime = 0;
      biosClickAudio.play().catch(function() {});
    });

    // Boot-up sound — try autoplay, fallback to mousemove, then click/key
    var bootupAudio = new Audio('assets/audio/sfx/old_bootup.mp3');
    bootupAudio.volume = 1.0;
    bootupAudio.loop = false;
    var bootAudioStarted = false;
    function tryPlayBootAudio() {
      if (bootAudioStarted) return;
      bootupAudio.play().then(function() {
        bootAudioStarted = true;
        document.removeEventListener('mousemove', tryPlayBootAudio);
        document.removeEventListener('pointerdown', tryPlayBootAudio);
        document.removeEventListener('keydown', tryPlayBootAudio);
      }).catch(function() {});
    }
    // Attempt 1: autoplay immediately
    tryPlayBootAudio();
    // Attempt 2: on mouse move
    document.addEventListener('mousemove', tryPlayBootAudio);
    // Attempt 3: on click or keypress
    document.addEventListener('pointerdown', tryPlayBootAudio);
    document.addEventListener('keydown', tryPlayBootAudio);

    // Dismiss handler — any key or tap after [ENTER] prompt is shown
    var dismissPointerStart = 0;
    var BIOS_TAP_THRESHOLD = 250; // ms — touch shorter than this = tap
    function handleDismissDown() {
      dismissPointerStart = Date.now();
    }
    function handleDismissUp() {
      if (!readyForEnter) return;
      if (Date.now() - dismissPointerStart < BIOS_TAP_THRESHOLD) {
        dismissOverlay();
      }
    }
    function handleDismissKey() {
      if (!readyForEnter) return;
      dismissOverlay();
    }
    document.addEventListener('pointerdown', handleDismissDown);
    document.addEventListener('pointerup', handleDismissUp);
    document.addEventListener('keydown', handleDismissKey);

    // Build flat character list, count dots/non-dots, assign progress thresholds
    var chars = [];
    var totalDots = 0;
    var totalNonDots = 0;
    for (var i = 0; i < lineEls.length; i++) {
      var text = lineEls[i].getAttribute('data-text') || '';
      lineEls[i].textContent = '';
      for (var j = 0; j < text.length; j++) {
        var isDot = text[j] === '.';
        chars.push({ el: lineEls[i], idx: j, fullText: text, isDot: isDot, threshold: 0 });
        if (isDot) totalDots++; else totalNonDots++;
      }
    }

    // Each dot eats DOT_TIME_PERCENT/totalDots of the progress range;
    // each non-dot eats (1-DOT_TIME_PERCENT)/totalNonDots — words fly through.
    var dotW    = totalDots    > 0 ? DOT_TIME_PERCENT / totalDots : 0;
    var nonDotW = totalNonDots > 0 ? (1 - DOT_TIME_PERCENT) / totalNonDots : 0;
    var cum = 0;
    for (var k = 0; k < chars.length; k++) {
      cum += chars[k].isDot ? dotW : nonDotW;
      chars[k].threshold = cum;
    }

    var revealed = 0;
    var targetProgress = 0;
    var typingDone = false;
    var loadingDone = false;
    var dismissed = false;
    var dripScheduled = false;

    // Drip: reveal one item per tick, only if loading progress allows it
    function drip() {
      dripScheduled = false;
      if (revealed >= chars.length) { typingDone = true; syncBar(); tryDismiss(); return; }
      if (chars[revealed].threshold > targetProgress) return; // wait for more progress

      var c = chars[revealed];
      if (c.isDot) {
        if (!c.el.classList.contains('visible')) c.el.classList.add('visible');
        c.el.textContent = c.fullText.substring(0, c.idx + 1);
        revealed++;
        syncBar();
        scheduleDrip(DOT_POP_MS);
      } else {
        // Batch all consecutive non-dots whose thresholds are earned
        while (revealed < chars.length && !chars[revealed].isDot && chars[revealed].threshold <= targetProgress) {
          var ch = chars[revealed];
          if (!ch.el.classList.contains('visible')) ch.el.classList.add('visible');
          ch.el.textContent = ch.fullText.substring(0, ch.idx + 1);
          revealed++;
        }
        syncBar();
        scheduleDrip(WORD_POP_MS);
      }
    }

    // Bar tracks typewriter progress, not raw load progress
    function syncBar() {
      var pct = chars.length > 0 ? (revealed / chars.length) * 100 : 0;
      fill.style.width = pct + '%';
    }

    function scheduleDrip(delay) {
      if (dripScheduled) return;
      if (revealed >= chars.length) { typingDone = true; tryDismiss(); return; }
      if (chars[revealed].threshold <= targetProgress) {
        dripScheduled = true;
        setTimeout(drip, delay);
      }
    }

    function revealAll() {
      for (var m = 0; m < lineEls.length; m++) {
        lineEls[m].classList.add('visible');
        lineEls[m].textContent = lineEls[m].getAttribute('data-text') || '';
      }
      revealed = chars.length;
      typingDone = true;
    }

    function fadeOutBootAudio() {
      var start = bootupAudio.volume;
      var dur = 500; // ms
      var step = 16;
      var decrement = start / (dur / step);
      var fade = setInterval(function() {
        var v = bootupAudio.volume - decrement;
        if (v <= 0) {
          clearInterval(fade);
          bootupAudio.volume = 0;
          bootupAudio.pause();
        } else {
          bootupAudio.volume = v;
        }
      }, step);
    }

    // BIOS complete chime — plays when loading finishes
    var biosCompleteAudio = new Audio('assets/audio/sfx/bios complete loading.mp3');
    biosCompleteAudio.volume = 1.0;
    var beepDone = false;
    var beepCallback = null;

    function onBeepFinished() {
      if (beepDone) return;
      beepDone = true;
      if (beepCallback) beepCallback();
    }
    biosCompleteAudio.addEventListener('ended', onBeepFinished, { once: true });
    biosCompleteAudio.addEventListener('error', onBeepFinished, { once: true });

    function tryDismiss() {
      if (readyForEnter || !typingDone || !loadingDone) return;
      // Loading done — show [ENTER] prompt, wait for user input
      readyForEnter = true;
      biosCompleteAudio.play().catch(function() { onBeepFinished(); });
      enterPrompt.style.display = 'block';
    }

    function dismissOverlay() {
      if (dismissed) return;
      dismissed = true;
      fadeOutBootAudio();

      // iOS audio unlock — must happen synchronously inside user gesture.
      // Create + resume an AudioContext so all subsequent Web Audio / Phaser sound works.
      // Also play+pause a silent HTML5 audio element to unlock <audio> for YouTube/Spotify.
      try {
        var unlockCtx = new (window.AudioContext || window.webkitAudioContext)();
        unlockCtx.resume().then(function() { unlockCtx.close(); });
      } catch(e) {}
      // Unlock Phaser's Web Audio context if it exists
      try {
        var phaserCtx = window.__phaserGame && window.__phaserGame.sound && window.__phaserGame.sound.context;
        if (phaserCtx && phaserCtx.state === 'suspended') phaserCtx.resume();
      } catch(e) {}
      // Unlock HTML5 Audio for YouTube IFrame / Spotify SDK
      try {
        var silentAudio = new Audio();
        silentAudio.src = 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=';
        silentAudio.volume = 0;
        silentAudio.play().then(function() { silentAudio.pause(); }).catch(function(){});
      } catch(e) {}
      // Activate Spotify Web Playback SDK audio element (iOS requires gesture context)
      try {
        if (window.__spotifyPlayer && window.__spotifyPlayer.activateElement) {
          window.__spotifyPlayer.activateElement();
        }
      } catch(e) {}
      // Unlock YouTube IFrame player audio (play+pause during gesture)
      try {
        if (window.__ytPlayer && window.__ytPlayer.playVideo) {
          window.__ytPlayer.playVideo();
          setTimeout(function() {
            try { window.__ytPlayer.pauseVideo(); } catch(e) {}
          }, 50);
        }
      } catch(e) {}

      document.removeEventListener('pointerdown', handleDismissDown);
      document.removeEventListener('pointerup', handleDismissUp);
      document.removeEventListener('keydown', handleDismissKey);
      overlay.style.transition = 'opacity 0.3s ease-out';
      overlay.style.opacity = '0';
      setTimeout(function() {
        overlay.classList.add('hidden');
        if (bootCursor && bootCursor.parentNode) bootCursor.parentNode.removeChild(bootCursor);
      }, 320);
    }

    // Start the drip immediately
    scheduleDrip(0);

    window.__bootOverlay = {
      setProgress: function(p) {
        if (dismissed) return;
        targetProgress = p;
        if (!dripScheduled) scheduleDrip(0);
      },
      markStartScreenReady: function() {
        if (loadingDone) return;
        loadingDone = true;
        targetProgress = 2;
        if (!typingDone && !dripScheduled) scheduleDrip(0);
        tryDismiss();
      },
      waitForBeep: function(cb) {
        if (beepDone) { cb(); return; }
        beepCallback = cb;
      },
      bootupAudio: bootupAudio,
      biosCompleteAudio: biosCompleteAudio,
      biosClickAudio: biosClickAudio
    };

    // --- Custom cursor (reads from window.__cursorConfig) ---
    var cc = window.__cursorConfig;
    var bootCursor = document.createElement('div');
    bootCursor.style.cssText = 'position:fixed;pointer-events:none;z-index:1;display:none;' +
      'animation:bios-jitter var(--bios-jitter-speed) infinite alternate;';
    var cursorImg = new Image();
    cursorImg.onload = function() {
      var aspect = cursorImg.naturalWidth / cursorImg.naturalHeight;
      var h = cc.size;
      var sw = cc.strokeW;
      var mainH = h, mainW = Math.round(h * aspect);
      var tintHex = '#' + cc.tint.toString(16).padStart(6, '0');
      var strokeHex = '#' + cc.strokeColor.toString(16).padStart(6, '0');
      var mask = '-webkit-mask-image:url(ui/cursor.png);mask-image:url(ui/cursor.png);' +
        '-webkit-mask-size:contain;mask-size:contain;' +
        '-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;' +
        '-webkit-mask-position:center;mask-position:center;' +
        'position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);';
      if (sw > 0) {
        var sH = h + sw * 2, sW = Math.round(sH * aspect);
        var strokeDiv = document.createElement('div');
        strokeDiv.style.cssText = mask + 'width:' + sW + 'px;height:' + sH + 'px;background:' + strokeHex + ';';
        bootCursor.appendChild(strokeDiv);
      }
      var mainDiv = document.createElement('div');
      mainDiv.style.cssText = mask + 'width:' + mainW + 'px;height:' + mainH + 'px;background:' + tintHex + ';';
      bootCursor.appendChild(mainDiv);
      overlay.appendChild(bootCursor);
    };
    cursorImg.src = 'ui/cursor.png';
    function updateBootCursor(clientX, clientY) {
      if (dismissed) return;
      bootCursor.style.display = '';
      bootCursor.style.left = (clientX + (cc.offsetX || 0)) + 'px';
      bootCursor.style.top = (clientY + (cc.offsetY || 0)) + 'px';
    }
    document.addEventListener('mousemove', function(e) { updateBootCursor(e.clientX, e.clientY); });
    document.addEventListener('pointerdown', function(e) { updateBootCursor(e.clientX, e.clientY); });
    document.addEventListener('pointermove', function(e) { updateBootCursor(e.clientX, e.clientY); });
  })();
  </script>

  <div id="game-container"></div>
  <script type="module" src="/src/main.ts"></script>
</body>
</html>
