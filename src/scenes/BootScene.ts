import Phaser from 'phaser';
import { TUNING } from '../config/tuning';
// AuthSystem imported dynamically in create() to keep Supabase SDK out of initial bundle
import { GAME_MODE, DEVICE_PROFILE } from '../config/gameMode';

export const TITLE_LOOP_FRAME_COUNT = 27;
export const TITLE_START_FRAME_COUNT = 25;
export const PRE_START_FRAME_COUNT = 46;
export const INTRO_TO_TUT_FRAME_COUNT = 27;

// Spritesheet frame dimensions at s50 (half-res of 1928×1076 originals)
// Generated by: node scripts/pack-spritesheet.mjs --all --scale 0.5
export const SHEET_FRAME_WIDTH = 964;
export const SHEET_FRAME_HEIGHT = 538;
export class BootScene extends Phaser.Scene {
  constructor() {
    super({ key: 'BootScene' });
  }

  preload() {
    // Apply BIOS volume as early as possible (bootup audio is already playing from index.html)
    const bootOverlay = (window as any).__bootOverlay;
    if (bootOverlay?.bootupAudio) bootOverlay.bootupAudio.volume = TUNING.SFX_BIOS_BOOTUP_VOLUME * TUNING.SFX_BIOS_MASTER;
    if (bootOverlay?.biosCompleteAudio) bootOverlay.biosCompleteAudio.volume = TUNING.SFX_BIOS_BEEP_VOLUME * TUNING.SFX_BIOS_MASTER;
    if (bootOverlay?.biosClickAudio) bootOverlay.biosClickAudio.volume = TUNING.SFX_CLICK_VOLUME * TUNING.SFX_CLICK_MASTER;

    // ── Boot Tracking (always active — enables retry + debug summary) ──
    const loadStartTime = Date.now();
    const failedAssets: Array<{ key: string; type: string; url: string; config?: any }> = [];
    let bootLoaded = 0, bootFailed = 0, bootTotal = 0;

    this.load.on('addfile', () => { bootTotal++; });
    this.load.on('filecomplete', () => { bootLoaded++; });
    this.load.on('loaderror', (file: any) => {
      bootFailed++;
      failedAssets.push({ key: file.key, type: file.type, url: file.url, config: file.config });
    });
    this.load.once('complete', () => {
      (window as any).__bootComplete = true;
      (window as any).__bootCounts = { loaded: bootLoaded, failed: bootFailed, total: bootTotal, elapsed: Date.now() - loadStartTime };
      (window as any).__bootFailedAssets = failedAssets;
    });

    // ── Debug Logging (only when ?debug=1) ──
    const debugMode = location.search.includes('debug=1');
    if (debugMode) {
      const loadTimers = new Map<string, number>();
      const lc = (window as any).__loaderConfig;
      console.log(`[boot] loader maxParallel=${lc?.maxParallel ?? '?'} source=${lc?.source ?? '?'} iOS=${lc?.ios ?? '?'}`);

      this.load.on('addfile', (file: any) => { loadTimers.set(file.key, Date.now()); });
      this.load.on('filecomplete', (key: string, type: string) => {
        const start = loadTimers.get(key);
        const dur = start ? Date.now() - start : -1;
        console.log(`[boot] ok: ${key} (${type}) ${dur}ms [${bootLoaded}/${bootTotal}]`);
      });
      this.load.on('loaderror', (file: any) => {
        const start = loadTimers.get(file.key);
        const dur = start ? Date.now() - start : -1;
        console.error(`[boot] FAIL: ${file.key} (${file.type}) ${dur}ms url=${file.url} [${bootFailed} failed]`);
      });
      this.load.once('complete', () => {
        console.log(`[boot] COMPLETE: ${bootLoaded} loaded, ${bootFailed} failed, ${Date.now() - loadStartTime}ms total`);
      });
    }

    // Report real load progress to the boot overlay (clamped 0..0.9)
    this.load.on('progress', (value: number) => {
      (window as any).__bootOverlay?.setProgress?.(value);
    });
    // Frame sequences: ~1.3 GB VRAM total on desktop
    // ?anim_level=N overrides, otherwise use device profile's titleAnimLevel
    const animLevelParam = new URLSearchParams(location.search).get('anim_level');
    const animLevel = animLevelParam !== null
      ? Math.max(0, Math.min(49, parseInt(animLevelParam, 10) || 0))
      : DEVICE_PROFILE.titleAnimLevel;
    (window as any).__animLevel = animLevel;

    // Load full animation if level is set (desktop/tablet=0, phone-high=25, phone-low=null)
    const loadTitleAnim = animLevel !== null;
    (window as any).__animFolder = loadTitleAnim ? 'spritesheet' : 'none';

    if (loadTitleAnim) {
      // Single spritesheet per sequence — 1 HTTP request, 1 GPU texture each
      // Uses s50 (half-res 964×538) for all devices — tested smooth on iPhone 12 Mini
      this.load.spritesheet('loop-sheet', 'assets/start/start_loop_sheet_s50.jpg', {
        frameWidth: SHEET_FRAME_WIDTH,
        frameHeight: SHEET_FRAME_HEIGHT,
      });
      this.load.spritesheet('play-sheet', 'assets/start/start_play_sheet_s50.jpg', {
        frameWidth: SHEET_FRAME_WIDTH,
        frameHeight: SHEET_FRAME_HEIGHT,
      });
    } else {
      // Mobile without ?anim_level: static first frame only
      this.load.image('start-loop-00', 'assets/start/start_loop/DP_Death_Ride_Title_Loop00.jpg');
    }

    // Pre-start cutscene sequence (46 frames)
    // Desktop: full-res PNGs from v02/ (1924×1076)
    // Mobile: half-res JPGs from v02_mobile/ (962×538, ~68MB VRAM — safe on 4GB phones)
    for (let i = 0; i < PRE_START_FRAME_COUNT; i++) {
      const idx = String(i).padStart(5, '0');
      if (GAME_MODE.mobileMode) {
        this.load.image(`pre-start-${idx}`, `assets/cutscenes/pre_start/v02_mobile/pre_start_v02__${idx}.jpg`);
      } else {
        this.load.image(`pre-start-${idx}`, `assets/cutscenes/pre_start/v02/pre_start_v02__${idx}.png`);
      }
    }

    if (!GAME_MODE.mobileMode) {
      // Desktop: full-res intro-to-tutorial
      for (let i = 0; i < INTRO_TO_TUT_FRAME_COUNT; i++) {
        const idx = String(i).padStart(5, '0');
        this.load.image(`intro-tut-${idx}`, `assets/cutscenes/intro_to_tut/v3/intro_to_tut_v03__${idx}.jpg`);
      }
    } else {
      // Mobile: compressed half-res intro-to-tutorial sequence (27 frames)
      for (let i = 0; i < INTRO_TO_TUT_FRAME_COUNT; i++) {
        const idx = String(i).padStart(5, '0');
        this.load.image(`intro-tut-${idx}`, `assets/cutscenes/intro_to_tut/v3_mobile/intro_to_tut_v03__${idx}.jpg`);
      }
    }
    // Mobile: load half-res nearest-neighbor sprite sheets (_mobile suffix)
    // Same texture keys, same animations, just smaller textures + frame dims
    const mob = GAME_MODE.mobileMode;
    const lite = GAME_MODE.liteMode;  // phone-low: skip heavy animation sheets (~77MB VRAM savings)
    const sfx = mob ? '_mobile' : '';                                     // file suffix
    const ms = TUNING.MOBILE_SPRITE_SCALE;
    const fw = (w: number) => mob ? Math.floor(w * ms) : w;              // scale frame width
    const fh = (h: number) => mob ? Math.floor(h * ms) : h;              // scale frame height

    this.load.spritesheet('player-ride', `assets/dp_player/dp_moto_v03${sfx}.png`, {
      frameWidth: fw(TUNING.PLAYER_FRAME_WIDTH),
      frameHeight: fh(TUNING.PLAYER_FRAME_HEIGHT),
    });
    // Lite mode: skip attack spritesheet too (11MB) — slash uses ride sprite + tint
    if (!lite) {
      this.load.spritesheet('player-attack', `assets/dp_player/dp_attack${sfx}.png`, {
        frameWidth: fw(TUNING.PLAYER_ATTACK_FRAME_WIDTH),
        frameHeight: fh(TUNING.PLAYER_ATTACK_FRAME_HEIGHT),
      });
    }
    // Lite mode: skip heavy animation spritesheets (start, powered, speedup, rocket-launch, COL)
    // Player stays in ride animation only — saves ~88MB VRAM on phone-low
    if (!lite) {
      this.load.spritesheet('player-start', `assets/dp_player/dp_start${sfx}.png`, {
        frameWidth: fw(TUNING.START_ANIM_FRAME_WIDTH),
        frameHeight: fh(TUNING.START_ANIM_FRAME_HEIGHT),
      });
      this.load.spritesheet('player-powered', `assets/dp_player/dp_powered_up${sfx}.png`, {
        frameWidth: fw(TUNING.POWERED_FRAME_WIDTH),
        frameHeight: fh(TUNING.POWERED_FRAME_HEIGHT),
      });
      this.load.spritesheet('player-speedup', `assets/dp_player/dp_speed_up${sfx}.png`, {
        frameWidth: fw(TUNING.SPEEDUP_FRAME_WIDTH),
        frameHeight: fh(TUNING.SPEEDUP_FRAME_HEIGHT),
      });
      this.load.spritesheet('player-rocket-launch', `assets/dp_player/dp_rocket_lancher_v2${sfx}.png`, {
        frameWidth: fw(TUNING.ROCKET_LAUNCHER_FRAME_WIDTH),
        frameHeight: fh(TUNING.ROCKET_LAUNCHER_FRAME_HEIGHT),
      });
      this.load.spritesheet('player-collect-rocket', `assets/COL/COL_rocket${sfx}.png`, {
        frameWidth: fw(TUNING.COL_FRAME_WIDTH),
        frameHeight: fh(TUNING.COL_FRAME_HEIGHT),
      });
      this.load.spritesheet('player-collect-shield', `assets/COL/COL_shield${sfx}.png`, {
        frameWidth: fw(TUNING.COL_FRAME_WIDTH),
        frameHeight: fh(TUNING.COL_FRAME_HEIGHT),
      });
      this.load.spritesheet('player-collect-hit', `assets/COL/COL_hit${sfx}.png`, {
        frameWidth: fw(TUNING.COL_FRAME_WIDTH),
        frameHeight: fh(TUNING.COL_FRAME_HEIGHT),
      });
    }
    this.load.spritesheet('rocket-projectile', `assets/pickups/rocket_Projectile${sfx}.png`, {
      frameWidth: fw(TUNING.ROCKET_PROJ_FRAME_W),
      frameHeight: fh(TUNING.ROCKET_PROJ_FRAME_H),
    });
    this.load.audio('countdown-music', 'assets/audio/music/hell_girl_countdown.mp3');
    this.load.audio('sfx-click', 'assets/audio/sfx/mouse click.mp3');
    this.load.audio('sfx-hover', 'assets/audio/sfx/mouse hover.mp3');
    this.load.audio('sfx-explode', 'assets/audio/sfx/explode.mp3');
    this.load.audio('sfx-rocket-fire', 'assets/audio/sfx/rocket_fire.mp3');
    this.load.audio('sfx-engine', 'assets/audio/sfx/motorcycle engine.mp3');
    this.load.audio('sfx-ammo-pickup', 'assets/audio/sfx/ammo_pickup.mp3');
    this.load.audio('sfx-obstacle-kill', 'assets/audio/sfx/obstacle_kill.mp3');
    this.load.audio('sfx-potion-pickup', 'assets/audio/sfx/potion_pickup.mp3');
    this.load.audio('sfx-potion-used', 'assets/audio/sfx/potion_used.mp3');
    this.load.spritesheet('pickup-rocket', `assets/pickups/rocket pickup${sfx}.png`, {
      frameWidth: fw(TUNING.PICKUP_FRAME_SIZE),
      frameHeight: fh(TUNING.PICKUP_FRAME_SIZE),
    });
    this.load.image('obstacle-crash', 'assets/obstacles/road_barrier_01.png');
    this.load.image('obstacle-reflection-alt', 'assets/obstacles/road_barrier_01_reflection_alt.png');
    // Puddle: load 2-JPG combo (color + alpha mask) — composited into RGBA in create()
    this.load.image('puddle-color', 'assets/background/puddle_color.jpg');
    this.load.image('puddle-alpha', 'assets/background/puddle_alpha.jpg');
    // Road + railing: vertical spritesheets — each frame is a 2048px-wide segment of the original.
    // Sequential sprites placed side-by-side restore full unique pattern at native aspect ratio.
    // Road: 6 frames × 2048×534 (from original 12001×534), Railing: 9 frames × 2048×100 (from 18559×100).
    this.load.spritesheet('road-img', 'assets/background/road_tile.jpg', { frameWidth: 2048, frameHeight: 534 });
    this.load.spritesheet('road-lines', 'assets/background/road_lines_tile.png', { frameWidth: 2048, frameHeight: 534 });
    if (lite) {
      this.load.image('railing', 'assets/background/railing_dark_mobile.jpg');
    } else {
      this.load.spritesheet('railing', 'assets/background/railing_tile.jpg', { frameWidth: 2048, frameHeight: 100 });
    }
    this.load.image('sky-img', 'assets/background/sky.jpg');
    this.load.image('buildings-back', 'assets/background/buildings_back_row_dark.png');
    this.load.image('buildings-front', 'assets/background/buildings_Front_row_dark.png');
    this.load.image('buildings-big', 'assets/background/buildings_Front_row_dark.png');

    // Car sprite sheets — tiny (20% scale, 15.8 MB VRAM for all 20)
    const carSfx = GAME_MODE.mobileMode ? '' : '';  // tiny has no suffix variant
    for (let c = 1; c <= TUNING.CAR_COUNT; c++) {
      const key = `car-${String(c).padStart(3, '0')}`;
      this.load.spritesheet(key, `assets/cars/tiny/car_${String(c).padStart(3, '0')}.png`, {
        frameWidth: Math.round(TUNING.CAR_FRAME_WIDTH * 0.2),
        frameHeight: Math.round(TUNING.CAR_FRAME_HEIGHT * 0.2),
      });
    }

    // Explosion sprite sheet
    this.load.spritesheet('explosion', `assets/vfx/vfx_explosion${sfx}.png`, {
      frameWidth: fw(TUNING.EXPLOSION_FRAME_SIZE),
      frameHeight: fh(TUNING.EXPLOSION_FRAME_SIZE),
    });

    // Slash VFX sprite sheet (8 frames horizontal strip, frame 0 is blank)
    this.load.spritesheet('slash-vfx', `assets/vfx/slash${sfx}.png`, {
      frameWidth: fw(TUNING.SLASH_VFX_FRAME_WIDTH),
      frameHeight: fh(TUNING.SLASH_VFX_FRAME_HEIGHT),
    });

    // Countdown sprite sheet (3×2 grid, 600×600 per frame, last frame blank)
    this.load.spritesheet('countdown', `assets/start/countdown${sfx}.png`, {
      frameWidth: fw(TUNING.COUNTDOWN_FRAME_SIZE),
      frameHeight: fh(TUNING.COUNTDOWN_FRAME_SIZE),
    });

    // UI assets
    this.load.image('spotify-text-logo', 'ui/spotify_text_logo_.png');
    this.load.image('sign-in', 'ui/sign_in.png');
    this.load.image('cursor', 'ui/cursor.png');
    this.load.image('crosshair', 'ui/crosshair.png');
    this.load.image('rocket-icon', 'assets/pickups/rocket_icon.png');
    this.load.image('rocket-icon-empty', 'assets/pickups/rocket_empty_icon.png');
    this.load.spritesheet('pickup-shield', `assets/pickups/shield_pickup${sfx}.png`, {
      frameWidth: fw(TUNING.SHIELD_FRAME_WIDTH),
      frameHeight: fh(TUNING.SHIELD_FRAME_HEIGHT),
    });
    this.load.image('shield-icon', 'assets/pickups/shield_icon.png');
    this.load.image('shield-icon-empty', 'assets/pickups/shield_empty_icon.png');
    this.load.image('ui-music-menu', 'ui/music menu.png');
    this.load.image('ui-skip', 'ui/skip.png');
    this.load.image('ui-unmuted', 'ui/unmuted.png');
    this.load.image('ui-muted', 'ui/muted.png');
    this.load.image('ui-insta', 'ui/insta.png');
    this.load.image('default-avatar', 'assets/profiles/dp_anon_pic.jpg');
    this.load.image('add-pic-icon', 'ui/add_pic_icon.png');

    // Tutorial assets
    this.load.image('tutorial-skip', 'assets/tutorial/skip_v02.png');
    if (!GAME_MODE.mobileMode) {
      this.load.image('tutorial-blank', 'assets/tutorial/how_to_play_v2.jpg');
      this.load.image('tutorial-obstacles', 'assets/tutorial/tut_v2/rules_v2.jpg');
      for (let i = 0; i < TUNING.TUTORIAL_CONTROLS_FRAMES; i++) {
        const idx = String(i).padStart(2, '0');
        const fileIdx = String(i).padStart(5, '0');
        this.load.image(`tutorial-controls-${idx}`, `assets/tutorial/controls_v4/controls_v4__${fileIdx}.jpg`);
      }
      for (let i = 0; i < TUNING.TUTORIAL_RAGE_FRAMES; i++) {
        this.load.image(`tutorial-rage-${i}`, `assets/tutorial/tut_v2/rage_v2/rage_v2_${i}.jpg`);
      }
    } else {
      // Mobile: load compressed half-res variants (87-97% smaller)
      this.load.image('tutorial-blank', 'assets/tutorial/how_to_play_v2_mobile.jpg');
      this.load.image('tutorial-obstacles', 'assets/tutorial/tut_v2/rules_v2_mobile.jpg');
      this.load.image('tutorial-controls-00', 'assets/tutorial/controls_v4_mobile/controls_v4__00000.jpg');
      this.load.image('tutorial-rage-0', 'assets/tutorial/tut_v2/rage_v2_mobile/rage_v2_0.jpg');
    }
  }

  async create() {
    // ── Retry failed assets with backoff (transient network-error recovery) ──
    const failedAssets = ((window as any).__bootFailedAssets || []) as Array<{ key: string; type: string; url: string; config?: any }>;
    let retryRecovered = 0;

    for (let attempt = 1; attempt <= 2 && failedAssets.length > 0; attempt++) {
      await new Promise(r => setTimeout(r, 500 * attempt)); // 500ms, 1000ms backoff
      const batch = failedAssets.splice(0); // take all, clear array
      console.log(`[boot] retry #${attempt}: re-downloading ${batch.length} asset(s)...`);

      for (const f of batch) {
        if (f.type === 'image') this.load.image(f.key, f.url);
        else if (f.type === 'spritesheet') this.load.spritesheet(f.key, f.url, f.config);
        else if (f.type === 'audio') this.load.audio(f.key, f.url);
      }

      if (this.load.list.size > 0) {
        await new Promise<void>(resolve => {
          this.load.once('complete', resolve);
          this.load.start();
        });
      }

      const recovered = batch.length - failedAssets.length;
      retryRecovered += recovered;
      console.log(`[boot] retry #${attempt}: ${recovered} recovered, ${failedAssets.length} still failed`);
    }

    // Create fallback textures for images that still failed after retries
    for (const f of failedAssets) {
      if (f.type === 'image' || f.type === 'spritesheet') {
        try {
          const fw = f.config?.frameWidth || 4;
          const fh = f.config?.frameHeight || 4;
          const g = this.add.graphics();
          g.fillStyle(0xff00ff, 0.3);
          g.fillRect(0, 0, fw, fh);
          g.generateTexture(f.key, fw, fh);
          g.destroy();
          console.warn(`[boot] placeholder texture: ${f.key} (${fw}x${fh})`);
        } catch (err) {
          console.warn(`[boot] failed to create placeholder for ${f.key}:`, err);
        }
      }
    }

    // Store final boot stats for debug summary
    const bootCounts = (window as any).__bootCounts || {};
    (window as any).__bootStats = { ...bootCounts, retryRecovered, stillFailed: failedAssets.map(f => f.key) };

    // ── Lite mode: generate procedural replacements for skipped textures ──
    // These tiny textures prevent crashes when GameScene references missing keys
    if (GAME_MODE.liteMode) {
      // Buildings-big: reuse buildings-front key (avoids duplicate 1920x163 load)
      if (!this.textures.exists('buildings-big')) {
        // Copy reference from buildings-front
        const bfTex = this.textures.get('buildings-front');
        if (bfTex) this.textures.addImage('buildings-big', bfTex.getSourceImage() as HTMLImageElement);
      }

      // Title frame: loaded for all mobile (no longer skipped in lite mode)

      // Player-attack: generate a minimal 1-frame spritesheet from player-ride frame 0
      if (!this.textures.exists('player-attack')) {
        const rideFrame = this.textures.getFrame('player-ride', 0);
        if (rideFrame) {
          const aw = rideFrame.width, ah = rideFrame.height;
          const attackCanvas = this.textures.createCanvas('player-attack', aw, ah)!;
          const actx = attackCanvas.getContext()!;
          actx.drawImage(rideFrame.source.image as HTMLImageElement, rideFrame.cutX, rideFrame.cutY, aw, ah, 0, 0, aw, ah);
          attackCanvas.refresh();
          // Add frame data so animations don't crash
          this.textures.get('player-attack').add(0, 0, 0, 0, aw, ah);
        }
      }

      console.log('[boot] Lite mode: procedural textures created (buildings-big, attack)');
    }

    // ── Composite puddle 2-JPG into single RGBA texture ──
    if (this.textures.exists('puddle-color') && this.textures.exists('puddle-alpha')) {
      const colorImg = this.textures.get('puddle-color').getSourceImage() as HTMLImageElement;
      const alphaImg = this.textures.get('puddle-alpha').getSourceImage() as HTMLImageElement;
      const pw = colorImg.naturalWidth, ph = colorImg.naturalHeight;
      const canvas = document.createElement('canvas');
      canvas.width = pw;
      canvas.height = ph;
      const ctx = canvas.getContext('2d')!;
      // Draw color image
      ctx.drawImage(colorImg, 0, 0);
      const imgData = ctx.getImageData(0, 0, pw, ph);
      // Draw alpha image to read its luminance
      ctx.drawImage(alphaImg, 0, 0);
      const alphaData = ctx.getImageData(0, 0, pw, ph);
      // Replace alpha channel with luminance from alpha JPG
      for (let i = 0; i < imgData.data.length; i += 4) {
        imgData.data[i + 3] = alphaData.data[i]; // R channel of grayscale = luminance
      }
      ctx.putImageData(imgData, 0, 0);
      this.textures.addCanvas('puddle-tex', canvas);
      // Clean up source textures
      this.textures.remove('puddle-color');
      this.textures.remove('puddle-alpha');
      console.log(`[boot] Puddle 2-JPG composited: ${pw}x${ph}`);
    }

    // Frame sequence animations — created from spritesheets
    const titleAnimLoaded = (window as any).__animLevel !== null;

    if (titleAnimLoaded) {
      // Spritesheet-based animations (Phaser anim objects used as fallback + metadata)
      // GameScene uses manual performance.now()-based frame stepping for smoothness
      this.anims.create({
        key: 'title-loop',
        frames: this.anims.generateFrameNumbers('loop-sheet', { start: 0, end: TITLE_LOOP_FRAME_COUNT - 1 }),
        frameRate: 12,
        repeat: -1,
      });
      this.anims.create({
        key: 'title-start',
        frames: this.anims.generateFrameNumbers('play-sheet', { start: 0, end: TITLE_START_FRAME_COUNT - 1 }),
        frameRate: 12,
        repeat: 0,
      });
    }

    // Pre-start cutscene animation (all platforms — mobile uses half-res JPGs)
    const preStartFrames: Phaser.Types.Animations.AnimationFrame[] = [];
    for (let i = 0; i < PRE_START_FRAME_COUNT; i++) {
      preStartFrames.push({ key: `pre-start-${String(i).padStart(5, '0')}` });
    }
    this.anims.create({ key: 'pre-start-cutscene', frames: preStartFrames, frameRate: 12, repeat: 0 });

    // Intro-to-tutorial cutscene animation (desktop: 27-frame sequence, mobile: single frame)
    const introTutFrameCount = INTRO_TO_TUT_FRAME_COUNT;
    const introTutFrames: Phaser.Types.Animations.AnimationFrame[] = [];
    for (let i = 0; i < introTutFrameCount; i++) {
      introTutFrames.push({ key: `intro-tut-${String(i).padStart(5, '0')}` });
    }
    this.anims.create({ key: 'intro-tut-cutscene', frames: introTutFrames, frameRate: 12, repeat: 0 });

    // Player ride animation (looping spritesheet) — always loaded
    this.anims.create({
      key: 'player-ride',
      frames: this.anims.generateFrameNumbers('player-ride', { start: 0, end: TUNING.PLAYER_ANIM_FRAMES - 1 }),
      frameRate: TUNING.PLAYER_RIDE_FPS,
      repeat: -1,
    });

    // Player attack animation — lite mode uses 1-frame placeholder (no multi-frame animation)
    if (!GAME_MODE.liteMode) {
      this.anims.create({
        key: 'player-attack',
        frames: this.anims.generateFrameNumbers('player-attack', { start: 0, end: TUNING.PLAYER_ATTACK_ANIM_FRAMES - 1 }),
        frameRate: TUNING.PLAYER_ATTACK_FPS,
        repeat: 0,
      });
    } else {
      // Lite: single-frame "animation" so sprite.play('player-attack') doesn't crash
      this.anims.create({
        key: 'player-attack',
        frames: [{ key: 'player-ride', frame: 0 }],
        frameRate: 1,
        repeat: 0,
      });
    }

    // Rocket projectile — intro plays full sequence once, then loops from frame LOOP_START
    this.anims.create({
      key: 'rocket-proj-intro',
      frames: this.anims.generateFrameNumbers('rocket-projectile', { start: 0, end: TUNING.ROCKET_PROJ_FRAMES - 1 }),
      frameRate: TUNING.ROCKET_PROJ_FPS,
      repeat: 0,
    });
    this.anims.create({
      key: 'rocket-proj-loop',
      frames: this.anims.generateFrameNumbers('rocket-projectile', { start: TUNING.ROCKET_PROJ_LOOP_START, end: TUNING.ROCKET_PROJ_FRAMES - 1 }),
      frameRate: TUNING.ROCKET_PROJ_FPS,
      repeat: -1,
    });

    // Lite mode: skip animations for textures that weren't loaded (saves ~77MB VRAM)
    if (!GAME_MODE.liteMode) {
      // Player start animation (plays once before ride loop)
      this.anims.create({
        key: 'player-start',
        frames: this.anims.generateFrameNumbers('player-start', { start: 0, end: TUNING.START_ANIM_FRAMES - 1 }),
        frameRate: TUNING.START_ANIM_FPS,
        repeat: 0,
      });

      // Player rocket launcher animation (plays once)
      this.anims.create({
        key: 'player-rocket-launch',
        frames: this.anims.generateFrameNumbers('player-rocket-launch', { start: 0, end: TUNING.ROCKET_LAUNCHER_ANIM_FRAMES - 1 }),
        frameRate: TUNING.ROCKET_LAUNCHER_FPS,
        repeat: 0,
      });

      // COL animations (all share same frame layout — rocket, shield, hit)
      for (const key of ['player-collect-rocket', 'player-collect-shield', 'player-collect-hit']) {
        this.anims.create({
          key,
          frames: this.anims.generateFrameNumbers(key, { start: 0, end: TUNING.COL_ANIM_FRAMES - 1 }),
          frameRate: TUNING.COL_FPS * TUNING.COL_SPEED,
          repeat: 0,
        });
      }

      // Powered-up intro (full sequence, plays once)
      this.anims.create({
        key: 'player-powered-intro',
        frames: this.anims.generateFrameNumbers('player-powered', { start: 0, end: TUNING.POWERED_ANIM_FRAMES - 1 }),
        frameRate: TUNING.POWERED_FPS,
        repeat: 0,
      });

      // Powered-up loop (last 4 frames, loops)
      this.anims.create({
        key: 'player-powered-loop',
        frames: this.anims.generateFrameNumbers('player-powered', { start: TUNING.POWERED_LOOP_START, end: TUNING.POWERED_ANIM_FRAMES - 1 }),
        frameRate: TUNING.POWERED_FPS,
        repeat: -1,
      });

      // Speed-up intro
      this.anims.create({
        key: 'player-speedup-intro',
        frames: this.anims.generateFrameNumbers('player-speedup', { start: 0, end: TUNING.SPEEDUP_INTRO_END }),
        frameRate: TUNING.SPEEDUP_FPS,
        repeat: 0,
      });

      // Speed-up loop
      this.anims.create({
        key: 'player-speedup-loop',
        frames: this.anims.generateFrameNumbers('player-speedup', { start: TUNING.SPEEDUP_LOOP_START, end: TUNING.SPEEDUP_LOOP_END }),
        frameRate: TUNING.SPEEDUP_FPS,
        repeat: -1,
      });

      // Speed-up outro
      this.anims.create({
        key: 'player-speedup-outro',
        frames: this.anims.generateFrameNumbers('player-speedup', { start: TUNING.SPEEDUP_OUTRO_START, end: TUNING.SPEEDUP_OUTRO_END }),
        frameRate: TUNING.SPEEDUP_FPS,
        repeat: 0,
      });
    }

    // Car drive animations — all 20 cars (tiny spritesheets)
    for (let c = 1; c <= TUNING.CAR_COUNT; c++) {
      const key = `car-${String(c).padStart(3, '0')}`;
      this.anims.create({
        key: `${key}-drive`,
        frames: this.anims.generateFrameNumbers(key, { start: 0, end: TUNING.CAR_ANIM_FRAMES - 1 }),
        frameRate: 12,
        repeat: -1,
      });
    }

    // Tutorial animations — desktop only (mobile shows static first frame)
    if (!GAME_MODE.mobileMode) {
      const tutControlsFrames: Phaser.Types.Animations.AnimationFrame[] = [];
      for (let i = 0; i < TUNING.TUTORIAL_CONTROLS_FRAMES; i++) {
        tutControlsFrames.push({ key: `tutorial-controls-${String(i).padStart(2, '0')}` });
      }
      this.anims.create({ key: 'tutorial-controls', frames: tutControlsFrames, frameRate: 12, repeat: -1 });

      const tutRageFrames: Phaser.Types.Animations.AnimationFrame[] = [];
      for (let i = 0; i < TUNING.TUTORIAL_RAGE_FRAMES; i++) {
        tutRageFrames.push({ key: `tutorial-rage-${i}` });
      }
      this.anims.create({ key: 'tutorial-rage', frames: tutRageFrames, frameRate: 12, repeat: -1 });
    }

    // Explosion animation (plays once at 12fps)
    this.anims.create({
      key: 'explosion-play',
      frames: this.anims.generateFrameNumbers('explosion', { start: 0, end: TUNING.EXPLOSION_ANIM_FRAMES - 1 }),
      frameRate: 12,
      repeat: 0,
    });

    // Slash VFX animation (frames 1-7, skipping blank frame 0)
    this.anims.create({
      key: 'slash-vfx-play',
      frames: this.anims.generateFrameNumbers('slash-vfx', {
        start: 1,
        end: TUNING.SLASH_VFX_FRAMES,
      }),
      frameRate: TUNING.SLASH_VFX_BASE_FPS * TUNING.SLASH_VFX_SPEED,
      repeat: 0,
    });

    // Rocket launcher pickup animation (looping spritesheet)
    this.anims.create({
      key: 'pickup-rocket-anim',
      frames: this.anims.generateFrameNumbers('pickup-rocket', { start: 0, end: TUNING.PICKUP_ANIM_FRAMES - 1 }),
      frameRate: TUNING.PICKUP_ANIM_FPS * TUNING.PICKUP_ANIM_SPEED,
      repeat: -1,
    });

    // Soft feathered glow texture for pickup (concentric circles = radial gradient)
    const glowSize = 256;
    const glowGfx = this.add.graphics();
    const glowSteps = 24;
    for (let i = 0; i < glowSteps; i++) {
      const ratio = 1 - i / glowSteps;
      glowGfx.fillStyle(0xffff00, 0.04);
      glowGfx.fillCircle(glowSize / 2, glowSize / 2, ratio * glowSize / 2);
    }
    glowGfx.generateTexture('pickup-glow', glowSize, glowSize);
    glowGfx.destroy();

    // Shield pickup animation (looping spritesheet)
    this.anims.create({
      key: 'pickup-shield-anim',
      frames: this.anims.generateFrameNumbers('pickup-shield', { start: 0, end: TUNING.SHIELD_ANIM_FRAMES - 1 }),
      frameRate: TUNING.SHIELD_ANIM_FPS * TUNING.SHIELD_ANIM_SPEED,
      repeat: -1,
    });

    // Soft feathered red glow texture for shield pickup
    const shieldGlowGfx = this.add.graphics();
    for (let i = 0; i < glowSteps; i++) {
      const ratio = 1 - i / glowSteps;
      shieldGlowGfx.fillStyle(0xff0000, 0.04);
      shieldGlowGfx.fillCircle(glowSize / 2, glowSize / 2, ratio * glowSize / 2);
    }
    shieldGlowGfx.generateTexture('shield-glow', glowSize, glowSize);
    shieldGlowGfx.destroy();

    // Soft feathered glow for rocket lane targeting (tight core, fast falloff)
    // Uses cubic falloff: brightness = (1 - r)^3 — hot center, drops quickly, long soft tail.
    const rocketGlowGfx = this.add.graphics();
    const rocketGlowSteps = TUNING.ROCKET_GLOW_STEPS;
    const peak = TUNING.ROCKET_GLOW_STEP_ALPHA * rocketGlowSteps;
    for (let i = 0; i < rocketGlowSteps; i++) {
      const radius = 1 - i / rocketGlowSteps; // 1.0 (outermost) → ~0 (innermost)
      // Target accumulated brightness: cubic falloff from center
      const bHere = peak * (1 - radius) * (1 - radius) * (1 - radius);
      const prevR = (i > 0) ? 1 - (i - 1) / rocketGlowSteps : 1.0;
      const bPrev = peak * (1 - prevR) * (1 - prevR) * (1 - prevR);
      const ringAlpha = Math.min(Math.max(bHere - bPrev, 0), 1);
      rocketGlowGfx.fillStyle(0xffffff, ringAlpha);
      rocketGlowGfx.fillCircle(glowSize / 2, glowSize / 2, radius * glowSize / 2);
    }
    rocketGlowGfx.generateTexture('rocket-lane-glow', glowSize, glowSize);
    rocketGlowGfx.destroy();

    // Rocket projectile spritesheet — loaded in preload(), animations created here

    // Force-load custom fonts before transitioning (non-critical — catch network errors)
    try {
      await Promise.all([
        document.fonts.load('48px "Early GameBoy"'),
        document.fonts.load('24px "Alagard"'),
      ]);
    } catch (err) {
      console.warn('[boot] font loading failed (non-critical):', err);
    }

    try {
      const { ensureAnonUser } = await import('../systems/AuthSystem');
      await ensureAnonUser();
    } catch (err) {
      console.warn('[boot] ensureAnonUser failed (non-critical):', err);
    }

    // ── Debug Boot Summary (on-screen overlay, ?debug=1 only) ──
    if (location.search.includes('debug=1')) {
      const stats = (window as any).__bootStats;
      if (stats) {
        const el = document.createElement('div');
        el.style.cssText = 'position:fixed;top:10px;left:10px;z-index:999998;background:rgba(0,0,0,0.85);color:#0f0;font:13px monospace;padding:8px 12px;border-radius:4px;pointer-events:none;max-width:400px;';
        let html = `Boot: ${stats.loaded}/${stats.total} loaded, ${stats.elapsed}ms`;
        if (stats.retryRecovered > 0) html += `<br><span style="color:#ff0">${stats.retryRecovered} recovered via retry</span>`;
        if (stats.stillFailed?.length > 0) {
          html += `<br><span style="color:#f00">${stats.stillFailed.length} FAILED: ${stats.stillFailed.join(', ')}</span>`;
        }
        el.innerHTML = html;
        document.body.appendChild(el);
        setTimeout(() => { el.style.transition = 'opacity 2s'; el.style.opacity = '0'; }, 15000);
        setTimeout(() => { try { document.body.removeChild(el); } catch {} }, 17000);
      }
    }

    const waitForGameScene = () => {
      if ((window as any).__gameSceneReady) {
        const loadErr = (window as any).__gameSceneError;
        if (loadErr) {
          console.error('[boot] GameScene chunk failed to load:', loadErr);
        } else {
          this.scene.start('GameScene');
        }
      } else {
        setTimeout(waitForGameScene, 100);
      }
    };
    waitForGameScene();
  }
}
